/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../wasm/pkg/loop_puzzle_web.js":
/*!**************************************!*\
  !*** ../wasm/pkg/loop_puzzle_web.js ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __wbg_buffer_55ba7a6b1b92e2ac: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_buffer_55ba7a6b1b92e2ac),
/* harmony export */   __wbg_call_557a2f2deacc4912: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_557a2f2deacc4912),
/* harmony export */   __wbg_call_587b30eea3e09332: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_587b30eea3e09332),
/* harmony export */   __wbg_crypto_70a96de3b6b73dac: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_crypto_70a96de3b6b73dac),
/* harmony export */   __wbg_getRandomValues_3774744e221a22ad: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_getRandomValues_3774744e221a22ad),
/* harmony export */   __wbg_globalThis_b70c095388441f2d: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_globalThis_b70c095388441f2d),
/* harmony export */   __wbg_global_1c72617491ed7194: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_global_1c72617491ed7194),
/* harmony export */   __wbg_msCrypto_adbc770ec9eca9c7: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_msCrypto_adbc770ec9eca9c7),
/* harmony export */   __wbg_new_09938a7d020f049b: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_09938a7d020f049b),
/* harmony export */   __wbg_newnoargs_c9e6043b8ad84109: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newnoargs_c9e6043b8ad84109),
/* harmony export */   __wbg_newwithbyteoffsetandlength_88d1d8be5df94b9b: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithbyteoffsetandlength_88d1d8be5df94b9b),
/* harmony export */   __wbg_newwithlength_89eeca401d8918c2: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithlength_89eeca401d8918c2),
/* harmony export */   __wbg_node_6a9d28205ed5b0d8: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_node_6a9d28205ed5b0d8),
/* harmony export */   __wbg_process_dd1577445152112e: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_process_dd1577445152112e),
/* harmony export */   __wbg_randomFillSync_e950366c42764a07: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_randomFillSync_e950366c42764a07),
/* harmony export */   __wbg_require_f05d779769764e82: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_require_f05d779769764e82),
/* harmony export */   __wbg_self_742dd6eab3e9211e: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_self_742dd6eab3e9211e),
/* harmony export */   __wbg_set_3698e3ca519b3c3c: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_3698e3ca519b3c3c),
/* harmony export */   __wbg_set_wasm: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm),
/* harmony export */   __wbg_subarray_d82be056deb4ad27: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_subarray_d82be056deb4ad27),
/* harmony export */   __wbg_versions_58036bec3add9e6f: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_versions_58036bec3add9e6f),
/* harmony export */   __wbg_window_c409e731db53a0e2: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_window_c409e731db53a0e2),
/* harmony export */   __wbindgen_is_function: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_function),
/* harmony export */   __wbindgen_is_object: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_object),
/* harmony export */   __wbindgen_is_string: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_string),
/* harmony export */   __wbindgen_is_undefined: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_undefined),
/* harmony export */   __wbindgen_memory: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_memory),
/* harmony export */   __wbindgen_object_clone_ref: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_object_clone_ref),
/* harmony export */   __wbindgen_object_drop_ref: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_object_drop_ref),
/* harmony export */   __wbindgen_string_new: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_string_new),
/* harmony export */   __wbindgen_throw: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_throw),
/* harmony export */   make_puzzle_web: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.make_puzzle_web),
/* harmony export */   make_puzzle_web2: () => (/* reexport safe */ _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.make_puzzle_web2)
/* harmony export */ });
/* harmony import */ var _loop_puzzle_web_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loop_puzzle_web_bg.wasm */ "../wasm/pkg/loop_puzzle_web_bg.wasm");
/* harmony import */ var _loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loop_puzzle_web_bg.js */ "../wasm/pkg/loop_puzzle_web_bg.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_loop_puzzle_web_bg_wasm__WEBPACK_IMPORTED_MODULE_1__]);
_loop_puzzle_web_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


(0,_loop_puzzle_web_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm)(_loop_puzzle_web_bg_wasm__WEBPACK_IMPORTED_MODULE_1__);


__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../wasm/pkg/loop_puzzle_web_bg.js":
/*!*****************************************!*\
  !*** ../wasm/pkg/loop_puzzle_web_bg.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __wbg_buffer_55ba7a6b1b92e2ac: () => (/* binding */ __wbg_buffer_55ba7a6b1b92e2ac),
/* harmony export */   __wbg_call_557a2f2deacc4912: () => (/* binding */ __wbg_call_557a2f2deacc4912),
/* harmony export */   __wbg_call_587b30eea3e09332: () => (/* binding */ __wbg_call_587b30eea3e09332),
/* harmony export */   __wbg_crypto_70a96de3b6b73dac: () => (/* binding */ __wbg_crypto_70a96de3b6b73dac),
/* harmony export */   __wbg_getRandomValues_3774744e221a22ad: () => (/* binding */ __wbg_getRandomValues_3774744e221a22ad),
/* harmony export */   __wbg_globalThis_b70c095388441f2d: () => (/* binding */ __wbg_globalThis_b70c095388441f2d),
/* harmony export */   __wbg_global_1c72617491ed7194: () => (/* binding */ __wbg_global_1c72617491ed7194),
/* harmony export */   __wbg_msCrypto_adbc770ec9eca9c7: () => (/* binding */ __wbg_msCrypto_adbc770ec9eca9c7),
/* harmony export */   __wbg_new_09938a7d020f049b: () => (/* binding */ __wbg_new_09938a7d020f049b),
/* harmony export */   __wbg_newnoargs_c9e6043b8ad84109: () => (/* binding */ __wbg_newnoargs_c9e6043b8ad84109),
/* harmony export */   __wbg_newwithbyteoffsetandlength_88d1d8be5df94b9b: () => (/* binding */ __wbg_newwithbyteoffsetandlength_88d1d8be5df94b9b),
/* harmony export */   __wbg_newwithlength_89eeca401d8918c2: () => (/* binding */ __wbg_newwithlength_89eeca401d8918c2),
/* harmony export */   __wbg_node_6a9d28205ed5b0d8: () => (/* binding */ __wbg_node_6a9d28205ed5b0d8),
/* harmony export */   __wbg_process_dd1577445152112e: () => (/* binding */ __wbg_process_dd1577445152112e),
/* harmony export */   __wbg_randomFillSync_e950366c42764a07: () => (/* binding */ __wbg_randomFillSync_e950366c42764a07),
/* harmony export */   __wbg_require_f05d779769764e82: () => (/* binding */ __wbg_require_f05d779769764e82),
/* harmony export */   __wbg_self_742dd6eab3e9211e: () => (/* binding */ __wbg_self_742dd6eab3e9211e),
/* harmony export */   __wbg_set_3698e3ca519b3c3c: () => (/* binding */ __wbg_set_3698e3ca519b3c3c),
/* harmony export */   __wbg_set_wasm: () => (/* binding */ __wbg_set_wasm),
/* harmony export */   __wbg_subarray_d82be056deb4ad27: () => (/* binding */ __wbg_subarray_d82be056deb4ad27),
/* harmony export */   __wbg_versions_58036bec3add9e6f: () => (/* binding */ __wbg_versions_58036bec3add9e6f),
/* harmony export */   __wbg_window_c409e731db53a0e2: () => (/* binding */ __wbg_window_c409e731db53a0e2),
/* harmony export */   __wbindgen_is_function: () => (/* binding */ __wbindgen_is_function),
/* harmony export */   __wbindgen_is_object: () => (/* binding */ __wbindgen_is_object),
/* harmony export */   __wbindgen_is_string: () => (/* binding */ __wbindgen_is_string),
/* harmony export */   __wbindgen_is_undefined: () => (/* binding */ __wbindgen_is_undefined),
/* harmony export */   __wbindgen_memory: () => (/* binding */ __wbindgen_memory),
/* harmony export */   __wbindgen_object_clone_ref: () => (/* binding */ __wbindgen_object_clone_ref),
/* harmony export */   __wbindgen_object_drop_ref: () => (/* binding */ __wbindgen_object_drop_ref),
/* harmony export */   __wbindgen_string_new: () => (/* binding */ __wbindgen_string_new),
/* harmony export */   __wbindgen_throw: () => (/* binding */ __wbindgen_throw),
/* harmony export */   make_puzzle_web: () => (/* binding */ make_puzzle_web),
/* harmony export */   make_puzzle_web2: () => (/* binding */ make_puzzle_web2)
/* harmony export */ });
/* module decorator */ module = __webpack_require__.hmd(module);
let wasm;
function __wbg_set_wasm(val) {
    wasm = val;
}


const heap = new Array(128).fill(undefined);

heap.push(undefined, null, true, false);

function getObject(idx) { return heap[idx]; }

let heap_next = heap.length;

function dropObject(idx) {
    if (idx < 132) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

const lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;

let cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

let cachedUint8Memory0 = null;

function getUint8Memory0() {
    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

let cachedInt32Memory0 = null;

function getInt32Memory0() {
    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}
/**
* @param {number} size_r
* @param {number} size_c
* @returns {string}
*/
function make_puzzle_web(size_r, size_c) {
    let deferred1_0;
    let deferred1_1;
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.make_puzzle_web(retptr, size_r, size_c);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        deferred1_0 = r0;
        deferred1_1 = r1;
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_free(deferred1_0, deferred1_1);
    }
}

/**
* @param {number} size_r
* @param {number} size_c
* @returns {string}
*/
function make_puzzle_web2(size_r, size_c) {
    let deferred1_0;
    let deferred1_1;
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.make_puzzle_web2(retptr, size_r, size_c);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        deferred1_0 = r0;
        deferred1_1 = r1;
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_free(deferred1_0, deferred1_1);
    }
}

function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        wasm.__wbindgen_exn_store(addHeapObject(e));
    }
}

function __wbg_crypto_70a96de3b6b73dac(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
};

function __wbindgen_is_object(arg0) {
    const val = getObject(arg0);
    const ret = typeof(val) === 'object' && val !== null;
    return ret;
};

function __wbg_process_dd1577445152112e(arg0) {
    const ret = getObject(arg0).process;
    return addHeapObject(ret);
};

function __wbg_versions_58036bec3add9e6f(arg0) {
    const ret = getObject(arg0).versions;
    return addHeapObject(ret);
};

function __wbg_node_6a9d28205ed5b0d8(arg0) {
    const ret = getObject(arg0).node;
    return addHeapObject(ret);
};

function __wbindgen_is_string(arg0) {
    const ret = typeof(getObject(arg0)) === 'string';
    return ret;
};

function __wbindgen_object_drop_ref(arg0) {
    takeObject(arg0);
};

function __wbg_msCrypto_adbc770ec9eca9c7(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
};

function __wbg_require_f05d779769764e82() { return handleError(function () {
    const ret = module.require;
    return addHeapObject(ret);
}, arguments) };

function __wbindgen_is_function(arg0) {
    const ret = typeof(getObject(arg0)) === 'function';
    return ret;
};

function __wbindgen_string_new(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
};

function __wbg_getRandomValues_3774744e221a22ad() { return handleError(function (arg0, arg1) {
    getObject(arg0).getRandomValues(getObject(arg1));
}, arguments) };

function __wbg_randomFillSync_e950366c42764a07() { return handleError(function (arg0, arg1) {
    getObject(arg0).randomFillSync(takeObject(arg1));
}, arguments) };

function __wbg_newnoargs_c9e6043b8ad84109(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

function __wbg_call_557a2f2deacc4912() { return handleError(function (arg0, arg1) {
    const ret = getObject(arg0).call(getObject(arg1));
    return addHeapObject(ret);
}, arguments) };

function __wbindgen_object_clone_ref(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
};

function __wbg_self_742dd6eab3e9211e() { return handleError(function () {
    const ret = self.self;
    return addHeapObject(ret);
}, arguments) };

function __wbg_window_c409e731db53a0e2() { return handleError(function () {
    const ret = window.window;
    return addHeapObject(ret);
}, arguments) };

function __wbg_globalThis_b70c095388441f2d() { return handleError(function () {
    const ret = globalThis.globalThis;
    return addHeapObject(ret);
}, arguments) };

function __wbg_global_1c72617491ed7194() { return handleError(function () {
    const ret = __webpack_require__.g.global;
    return addHeapObject(ret);
}, arguments) };

function __wbindgen_is_undefined(arg0) {
    const ret = getObject(arg0) === undefined;
    return ret;
};

function __wbg_call_587b30eea3e09332() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
}, arguments) };

function __wbg_buffer_55ba7a6b1b92e2ac(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
};

function __wbg_newwithbyteoffsetandlength_88d1d8be5df94b9b(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
};

function __wbg_new_09938a7d020f049b(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
};

function __wbg_set_3698e3ca519b3c3c(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
};

function __wbg_newwithlength_89eeca401d8918c2(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
};

function __wbg_subarray_d82be056deb4ad27(arg0, arg1, arg2) {
    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
};

function __wbindgen_throw(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
};

function __wbindgen_memory() {
    const ret = wasm.memory;
    return addHeapObject(ret);
};



/***/ }),

/***/ "./ts/index.ts":
/*!*********************!*\
  !*** ./ts/index.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const stage_1 = __webpack_require__(/*! ./stage */ "./ts/stage.ts");
let make_puzzle_web;
let make_puzzle_web2;
Promise.resolve().then(() => __importStar(__webpack_require__(/*! ../node_modules/loop_puzzle_web/loop_puzzle_web.js */ "../wasm/pkg/loop_puzzle_web.js"))).then((js) => __awaiter(void 0, void 0, void 0, function* () {
    make_puzzle_web = (yield js.default).make_puzzle_web;
    make_puzzle_web2 = (yield js.default).make_puzzle_web2;
}));
let stage;
function init() {
    return __awaiter(this, void 0, void 0, function* () {
        let stageSvg = document.getElementById("stage");
        let uiOptionForm = document.getElementById("ui-option");
        stage = new stage_1.Stage(stageSvg);
        let preventClick = false;
        stageSvg.addEventListener("click", (ev) => {
            if (!preventClick) {
                let stageRect = stageSvg.getBoundingClientRect();
                if (uiOptionForm["line-noline"].value == "line") {
                    stage.click(ev.clientX - stageRect.left, ev.clientY - stageRect.top);
                }
                else {
                    stage.rclick(ev.clientX - stageRect.left, ev.clientY - stageRect.top);
                }
            }
            else {
                preventClick = false;
            }
        });
        stageSvg.addEventListener("contextmenu", (ev) => {
            ev.preventDefault();
            if (!preventClick) {
                let stageRect = stageSvg.getBoundingClientRect();
                if (uiOptionForm["line-noline"].value == "line") {
                    stage.rclick(ev.clientX - stageRect.left, ev.clientY - stageRect.top);
                }
                else {
                    stage.click(ev.clientX - stageRect.left, ev.clientY - stageRect.top);
                }
            }
            else {
                preventClick = false;
            }
        });
        // PC
        {
            const PREVENT_CLICK_MOVE_DIST = 10;
            document.addEventListener("keydown", (ev) => {
                // svg element won't be active. so insteadly check if "body is active".
                if (document.activeElement == document.body) {
                    if (ev.ctrlKey) {
                        switch (ev.code) {
                            case "KeyZ": {
                                stage.loadLineInfo(stage.lineInfoIndex - 1);
                                ev.preventDefault();
                            }
                            case "KeyY": {
                                stage.loadLineInfo(stage.lineInfoIndex + 1);
                                ev.preventDefault();
                            }
                        }
                    }
                }
            });
            let dragging = false;
            let dragX = 0;
            let dragY = 0;
            let scrollX = 0;
            let scrollY = 0;
            // scroll
            stageSvg.addEventListener("mousedown", (ev) => {
                dragging = true;
                dragX = ev.clientX;
                dragY = ev.clientY;
                scrollX = stage.scrollX;
                scrollY = stage.scrollY;
            });
            window.addEventListener("mousemove", (ev) => {
                if (dragging) {
                    stage.scroll(ev.clientX - dragX + scrollX, ev.clientY - dragY + scrollY);
                    // prevent click
                    if ((ev.clientX - dragX) * (ev.clientX - dragX) + (ev.clientY - dragY) * (ev.clientY - dragY) > PREVENT_CLICK_MOVE_DIST * PREVENT_CLICK_MOVE_DIST) {
                        preventClick = true;
                    }
                }
            });
            window.addEventListener("mouseup", () => {
                dragging = false;
            });
            // scale
            stageSvg.addEventListener("wheel", (ev) => {
                ev.preventDefault();
                let stageRect = stageSvg.getBoundingClientRect();
                let cx = ev.clientX - stageRect.left;
                let cy = ev.clientY - stageRect.top;
                if (ev.deltaY > 0) {
                    stage.scaleUp(cx, cy);
                }
                else {
                    stage.scaleDown(cx, cy);
                }
            });
        }
        { // Mobile
            let prevCX = -1;
            let prevCY = -1;
            let prevDist = -1;
            let initDist = -1;
            const SCALE_INTERVAL = 20;
            let gestureStarted = false;
            let pointers = [];
            function getDistance() {
                return Math.sqrt((pointers[0].clientX - pointers[1].clientX) * (pointers[0].clientX - pointers[1].clientX) +
                    (pointers[0].clientY - pointers[1].clientY) * (pointers[0].clientY - pointers[1].clientY));
            }
            // scale
            function pointerRemove(ev) {
                // remove pointer
                let pointerIndex = pointers.findIndex(v => v.pointerId == ev.pointerId);
                if (pointerIndex != -1) {
                    pointers.splice(pointerIndex, 1);
                }
                // reset previous distance of 2 pointers
                gestureStarted = false;
            }
            // prevent default event (pinch operation)
            document.body.addEventListener('touchmove', (e) => {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
            stageSvg.addEventListener("pointerout", pointerRemove);
            stageSvg.addEventListener("pointerup", pointerRemove);
            stageSvg.addEventListener("pointercancel", pointerRemove);
            stageSvg.addEventListener("pointerdown", (ev) => {
                pointers.push(ev);
                if (pointers.length >= 2) {
                    preventClick = false;
                }
            });
            stageSvg.addEventListener("pointermove", (ev) => {
                // update pointer
                let pointerIndex = pointers.findIndex(v => v.pointerId == ev.pointerId);
                if (pointerIndex != -1) {
                    pointers[pointerIndex] = ev;
                }
                if (pointers.length >= 2) {
                    ev.preventDefault();
                    let currCX = (pointers[0].clientX + pointers[1].clientX) / 2;
                    let currCY = (pointers[0].clientY + pointers[1].clientY) / 2;
                    let currDist = getDistance();
                    let prevScaleIndex = Math.floor((prevDist - initDist) / SCALE_INTERVAL);
                    let currScaleIndex = Math.floor((currDist - initDist) / SCALE_INTERVAL);
                    // pinch out / pinch in
                    if (!gestureStarted) {
                        gestureStarted = true;
                    }
                    else {
                        // scale
                        if (currScaleIndex > prevScaleIndex) {
                            // scale up
                            for (let i = 0; i < currScaleIndex - prevScaleIndex; i++) {
                                stage.scaleUp(currCX, currCY);
                            }
                        }
                        else if (currScaleIndex < prevScaleIndex) {
                            // scale down
                            for (let i = 0; i < prevScaleIndex - currScaleIndex; i++) {
                                stage.scaleDown(currCX, currCY);
                            }
                        }
                        // move
                        if (currCX != prevCX || currCY != prevCY) {
                            stage.scroll(stage.scrollX + currCX - prevCX, stage.scrollY + currCY - prevCY);
                        }
                    }
                    prevCX = currCX;
                    prevCY = currCY;
                    prevDist = currDist;
                }
                else {
                    gestureStarted = false;
                    preventClick = false;
                }
            });
        }
        document.getElementById("new_puzzle").addEventListener("click", () => {
            let width = Number(document.getElementById("stage_width").value);
            let height = Number(document.getElementById("stage_height").value);
            let puzzle_string = make_puzzle_web2(height, width);
            stage.init(width, height, puzzle_string);
        });
        document.getElementById("undo").addEventListener("click", () => {
            stage.loadLineInfo(stage.lineInfoIndex - 1);
        });
        document.getElementById("redo").addEventListener("click", () => {
            stage.loadLineInfo(stage.lineInfoIndex + 1);
        });
    });
}
function waitLoad() {
    if (document.body) {
        init();
    }
    else {
        setTimeout(waitLoad, 10);
    }
}
waitLoad();


/***/ }),

/***/ "./ts/stage.ts":
/*!*********************!*\
  !*** ./ts/stage.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LineItem = exports.Stage = void 0;
const NS_SVG = "http://www.w3.org/2000/svg";
const MARGIN_STAGE = 10;
const LINE_LENGTH = 40;
const NUMBER_FONT_SIZE = "25";
const NUMBER_FONT_Y_ADJUST = 10;
class Stage {
    constructor(stage) {
        this.stage = stage;
        this.v_line = [];
        this.h_line = [];
        this.width = 0;
        this.height = 0;
        this.lineInfos = [];
        this.lineInfoIndex = -1;
        this.scrollX = 0;
        this.scrollY = 0;
        this.scale = 1;
        this.scaleIndex = 3;
        this.puzzleLayer = document.createElementNS(NS_SVG, "g");
        this.decorationLayer = document.createElementNS(NS_SVG, "g");
        stage.append(this.puzzleLayer);
        stage.append(this.decorationLayer);
    }
    init(width, height, data) {
        this.puzzleLayer.innerHTML = "";
        this.decorationLayer.innerHTML = "";
        this.v_line.length = 0;
        this.h_line.length = 0;
        this.width = width;
        this.height = height;
        // V lines
        for (let r = 0; r < height; r++) {
            this.v_line.push([]);
            for (let c = 0; c < width + 1; c++) {
                this.v_line[r].push(new LineItem(this.puzzleLayer, c, r, true));
            }
        }
        // H lines
        for (let r = 0; r < height + 1; r++) {
            this.h_line.push([]);
            for (let c = 0; c < width; c++) {
                this.h_line[r].push(new LineItem(this.puzzleLayer, c, r, false));
            }
        }
        // numbers
        let numberStrings = data.split("|");
        for (let r = 0; r < height; r++) {
            for (let c = 0; c < width; c++) {
                if (numberStrings[r][c] != " ") {
                    let text = document.createElementNS(NS_SVG, "text");
                    text.innerHTML = numberStrings[r][c];
                    text.setAttribute("font-size", NUMBER_FONT_SIZE);
                    text.setAttribute("x", (MARGIN_STAGE + (c + 0.5) * LINE_LENGTH).toString());
                    text.setAttribute("y", (MARGIN_STAGE + (r + 0.5) * LINE_LENGTH + NUMBER_FONT_Y_ADJUST).toString());
                    text.setAttribute("text-anchor", "middle");
                    this.puzzleLayer.append(text);
                }
            }
        }
        // save number-info
        this.numberInfo = {
            numbers: numberStrings.map(v => {
                let num_line = [];
                for (let c = 0; c < width; c++) {
                    num_line.push(v[c] == " " ? -1 : v[c].charCodeAt(0) - '0'.charCodeAt(0));
                }
                return num_line;
            })
        };
        this.lineInfos.length = 0;
        this.lineInfoIndex = 0;
        this.saveLineInfo();
        this.assist();
        this.saveLineInfo();
    }
    getClosestLine(x, y) {
        let stagePosX = (x - this.scrollX) / this.scale;
        let stagePosY = (y - this.scrollY) / this.scale;
        let fx = Math.floor((stagePosX - MARGIN_STAGE) / LINE_LENGTH);
        let rx = stagePosX - fx * LINE_LENGTH - MARGIN_STAGE;
        let fy = Math.floor((stagePosY - MARGIN_STAGE) / LINE_LENGTH);
        let ry = stagePosY - fy * LINE_LENGTH - MARGIN_STAGE;
        let isVirtical;
        if (rx < ry && rx + ry < LINE_LENGTH) {
            isVirtical = true;
        }
        else if (rx + ry < LINE_LENGTH) {
            isVirtical = false;
        }
        else if (rx < ry) {
            isVirtical = false;
            fy++;
        }
        else {
            isVirtical = true;
            fx++;
        }
        return {
            fx: fx,
            fy: fy,
            isVirtical: isVirtical,
            inFrame: (isVirtical && fx >= 0 && fx < this.width + 1 && fy >= 0 && fy < this.height) ||
                (!isVirtical && fx >= 0 && fx < this.width && fy >= 0 && fy < this.height + 1)
        };
    }
    click(x, y) {
        let { fx, fy, isVirtical, inFrame } = this.getClosestLine(x, y);
        if (inFrame) {
            if (isVirtical) {
                this.v_line[fy][fx].click();
            }
            else {
                this.h_line[fy][fx].click();
            }
            this.assist();
            this.saveLineInfo();
            if (this.checkCleared()) {
                this.complete();
            }
        }
    }
    rclick(x, y) {
        let { fx, fy, isVirtical, inFrame } = this.getClosestLine(x, y);
        if (inFrame) {
            if (isVirtical) {
                this.v_line[fy][fx].rclick();
            }
            else {
                this.h_line[fy][fx].rclick();
            }
            this.assist();
            this.saveLineInfo();
        }
    }
    saveLineInfo() {
        this.lineInfos.length = this.lineInfoIndex + 1;
        this.lineInfos.push({
            h_line: this.h_line.map(u => u.map(v => {
                switch (v.getLineType()) {
                    case "line": return 1;
                    case "no-line": return 0;
                    case "none": return -1;
                }
            })),
            v_line: this.v_line.map(u => u.map(v => {
                switch (v.getLineType()) {
                    case "line": return 1;
                    case "no-line": return 0;
                    case "none": return -1;
                }
            }))
        });
        this.lineInfoIndex++;
    }
    loadLineInfo(index) {
        if (index < 0 || index >= this.lineInfos.length) {
            return;
        }
        this.lineInfoIndex = index;
        let lineInfo = this.lineInfos[this.lineInfoIndex];
        function lineTypeToInfo(v) {
            switch (v) {
                case -1: return "none";
                case 0: return "no-line";
                case 1: return "line";
                default: return "none";
            }
        }
        ;
        this.v_line.map((v, r) => v.map((v, c) => {
            v.setLineType(lineTypeToInfo(lineInfo.v_line[r][c]));
        }));
        this.h_line.map((v, r) => v.map((v, c) => {
            v.setLineType(lineTypeToInfo(lineInfo.h_line[r][c]));
        }));
    }
    setDisplay() {
        this.puzzleLayer.setAttribute("transform", `translate(${this.scrollX} ${this.scrollY}) scale(${this.scale})`);
    }
    scroll(x, y) {
        this.scrollX = x;
        this.scrollY = y;
        this.setDisplay();
    }
    changeScale(scale, cx, cy) {
        this.scrollX = cx - (cx - this.scrollX) * scale / this.scale;
        this.scrollY = cy - (cy - this.scrollY) * scale / this.scale;
        this.scale = scale;
        this.setDisplay();
    }
    scaleUp(cx, cy) {
        if (this.scaleIndex + 1 >= Stage.scaleList.length) {
            return;
        }
        this.scaleIndex += 1;
        this.changeScale(Stage.scaleList[this.scaleIndex], cx, cy);
    }
    scaleDown(cx, cy) {
        if (this.scaleIndex - 1 < 0) {
            return;
        }
        this.scaleIndex -= 1;
        this.changeScale(Stage.scaleList[this.scaleIndex], cx, cy);
    }
    getNumber(r, c) {
        var _a, _b;
        return (_b = (_a = this.numberInfo) === null || _a === void 0 ? void 0 : _a.numbers[r][c]) !== null && _b !== void 0 ? _b : -1;
    }
    getVLineType(r, c) {
        var _a;
        if (r < 0 || r >= this.height || c < 0 || c >= this.width + 1) {
            return "no-line";
        }
        return (_a = this.v_line[r][c].getLineType()) !== null && _a !== void 0 ? _a : -1;
    }
    getHLineType(r, c) {
        var _a;
        if (r < 0 || r >= this.height + 1 || c < 0 || c >= this.width) {
            return "no-line";
        }
        return (_a = this.h_line[r][c].getLineType()) !== null && _a !== void 0 ? _a : -1;
    }
    getLineType(r, c, isVirtical) {
        if (isVirtical) {
            return this.getVLineType(r, c);
        }
        else {
            return this.getHLineType(r, c);
        }
    }
    setVLineType(r, c, type) {
        this.v_line[r][c].setLineType(type);
    }
    setHLineType(r, c, type) {
        this.h_line[r][c].setLineType(type);
    }
    setLineType(r, c, isVirtical, type) {
        if (isVirtical) {
            return this.setVLineType(r, c, type);
        }
        else {
            return this.setHLineType(r, c, type);
        }
    }
    *iterateAllNumbers() {
        for (let r = 0; r < this.height; r++) {
            for (let c = 0; c < this.width; c++) {
                yield [r, c];
            }
        }
    }
    *iterateAllPoints() {
        for (let r = 0; r < this.height + 1; r++) {
            for (let c = 0; c < this.width + 1; c++) {
                yield [r, c];
            }
        }
    }
    *iterateAllLines() {
        for (let r = 0; r < this.height; r++) {
            for (let c = 0; c < this.width + 1; c++) {
                yield [r, c, true];
            }
        }
        for (let r = 0; r < this.height + 1; r++) {
            for (let c = 0; c < this.width; c++) {
                yield [r, c, false];
            }
        }
    }
    assist() {
        let changed = false;
        while (true) {
            changed = false;
            // numbers
            for (let [r, c] of this.iterateAllNumbers()) {
                let num = this.getNumber(r, c);
                if (num >= 0) {
                    let countLine = 0;
                    let countNoLine = 0;
                    for (let [dr, dc, isVirtical] of Stage.lineArroundNumber) {
                        if (this.getLineType(r + dr, c + dc, isVirtical) == "line") {
                            countLine++;
                        }
                        else if (this.getLineType(r + dr, c + dc, isVirtical) == "no-line") {
                            countNoLine++;
                        }
                    }
                    if (countLine + countNoLine == 4) {
                        continue;
                    }
                    else if (countLine == num) {
                        for (let [dr, dc, isVirtical] of Stage.lineArroundNumber) {
                            if (this.getLineType(r + dr, c + dc, isVirtical) == "none") {
                                this.setLineType(r + dr, c + dc, isVirtical, "no-line");
                            }
                        }
                        changed = true;
                    }
                    else if (countNoLine + num == 4) {
                        for (let [dr, dc, isVirtical] of Stage.lineArroundNumber) {
                            if (this.getLineType(r + dr, c + dc, isVirtical) == "none") {
                                this.setLineType(r + dr, c + dc, isVirtical, "line");
                            }
                        }
                        changed = true;
                    }
                }
            }
            // points
            for (let [r, c] of this.iterateAllPoints()) {
                let countLine = 0;
                let countNoLine = 0;
                for (let [dr, dc, isVirtical] of Stage.lineArroundPoint) {
                    if (this.getLineType(r + dr, c + dc, isVirtical) == "line") {
                        countLine++;
                    }
                    else if (this.getLineType(r + dr, c + dc, isVirtical) == "no-line") {
                        countNoLine++;
                    }
                }
                if (countLine + countNoLine == 4) {
                    continue;
                }
                else if (countLine == 2 || countNoLine == 3) {
                    for (let [dr, dc, isVirtical] of Stage.lineArroundPoint) {
                        if (this.getLineType(r + dr, c + dc, isVirtical) == "none") {
                            this.setLineType(r + dr, c + dc, isVirtical, "no-line");
                        }
                    }
                    changed = true;
                }
                else if (countNoLine == 2 && countLine == 1) {
                    for (let [dr, dc, isVirtical] of Stage.lineArroundPoint) {
                        if (this.getLineType(r + dr, c + dc, isVirtical) == "none") {
                            this.setLineType(r + dr, c + dc, isVirtical, "line");
                        }
                    }
                    changed = true;
                }
            }
            if (!changed) {
                break;
            }
        }
    }
    checkCleared() {
        // check number
        {
            for (let [r, c] of this.iterateAllNumbers()) {
                let num = this.getNumber(r, c);
                if (num >= 0) {
                    let countLine = 0;
                    for (let [dr, dc, isVirtical] of Stage.lineArroundNumber) {
                        if (this.getLineType(r + dr, c + dc, isVirtical) == "line") {
                            countLine++;
                        }
                    }
                    if (num != countLine) {
                        return false;
                    }
                }
            }
        }
        // check points
        {
            for (let [r, c] of this.iterateAllNumbers()) {
                let countLine = 0;
                for (let [dr, dc, isVirtical] of Stage.lineArroundPoint) {
                    if (this.getLineType(r + dr, c + dc, isVirtical) == "line") {
                        countLine++;
                    }
                }
                if (countLine == 1 || countLine == 3 || countLine == 4) {
                    return false;
                }
            }
        }
        // check global loop
        {
            let groupPoints = [];
            let joinGroup = (num1, num2) => {
                if (num1 == num2) {
                    return;
                }
                for (let [r, c] of this.iterateAllPoints()) {
                    if (groupPoints[r][c] == num2) {
                        groupPoints[r][c] = num1;
                    }
                }
            };
            for (let r = 0; r < this.height + 1; r++) {
                groupPoints.push([]);
                for (let c = 0; c < this.width + 1; c++) {
                    groupPoints[r].push(-1);
                }
            }
            for (let [r, c] of this.iterateAllPoints()) {
                let countLine = 0;
                for (let [dr, dc, isVirtical] of Stage.lineArroundPoint) {
                    if (this.getLineType(r + dr, c + dc, isVirtical) == "line") {
                        countLine++;
                    }
                }
                if (countLine == 0) {
                    groupPoints[r][c] = -1;
                }
                else if (countLine == 2) {
                    groupPoints[r][c] = r * (this.width + 1) + c;
                }
            }
            for (let [r, c, isVirtical] of this.iterateAllLines()) {
                if (this.getLineType(r, c, isVirtical) == "line") {
                    if (isVirtical) {
                        joinGroup(groupPoints[r][c], groupPoints[r + 1][c]);
                    }
                    else {
                        joinGroup(groupPoints[r][c], groupPoints[r][c + 1]);
                    }
                }
            }
            let group = -1;
            for (let [r, c] of this.iterateAllPoints()) {
                if (groupPoints[r][c] == -1 || groupPoints[r][c] == group) {
                    continue;
                }
                else if (group == -1) {
                    group = groupPoints[r][c];
                    continue;
                }
                else {
                    return false;
                }
            }
            if (group == -1) {
                return false;
            }
        }
        return true;
    }
    complete() {
        if (this.completeText) {
            this.completeText.remove();
        }
        this.completeText = document.createElementNS(NS_SVG, "text");
        let stageRect = this.stage.getBoundingClientRect();
        this.completeText.innerHTML = "COMPLETE";
        this.completeText.setAttribute("x", (stageRect.width / 2).toString());
        this.completeText.setAttribute("y", (stageRect.height / 2).toString());
        this.completeText.setAttribute("transform", `rotate(-30 ${stageRect.width / 2}, ${stageRect.height / 2})`);
        this.completeText.classList.add("complete");
        this.decorationLayer.append(this.completeText);
    }
}
exports.Stage = Stage;
Stage.lineArroundNumber = [[0, 0, true], [0, 0, false], [0, 1, true], [1, 0, false]];
Stage.lineArroundPoint = [[0, 0, true], [0, 0, false], [-1, 0, true], [0, -1, false]];
Stage.scaleList = [0.25, 0.5, 0.75, 1, 1.5, 2, 3, 5];
class LineItem {
    constructor(stage, x, y, isVirtical) {
        this.stage = stage;
        this.isVirtical = isVirtical;
        this.type = "none";
        this.line = document.createElementNS(NS_SVG, "line");
        stage.append(this.line);
        if (this.isVirtical) {
            this.line.setAttribute("x1", (MARGIN_STAGE + x * LINE_LENGTH).toString());
            this.line.setAttribute("y1", (MARGIN_STAGE + y * LINE_LENGTH).toString());
            this.line.setAttribute("x2", (MARGIN_STAGE + x * LINE_LENGTH).toString());
            this.line.setAttribute("y2", (MARGIN_STAGE + (y + 1) * LINE_LENGTH).toString());
        }
        else {
            this.line.setAttribute("x1", (MARGIN_STAGE + x * LINE_LENGTH).toString());
            this.line.setAttribute("y1", (MARGIN_STAGE + y * LINE_LENGTH).toString());
            this.line.setAttribute("x2", (MARGIN_STAGE + (x + 1) * LINE_LENGTH).toString());
            this.line.setAttribute("y2", (MARGIN_STAGE + y * LINE_LENGTH).toString());
        }
        this.redraw();
    }
    click() {
        if (this.type == "line") {
            this.type = "none";
        }
        else {
            this.type = "line";
        }
        this.redraw();
    }
    rclick() {
        if (this.type == "no-line") {
            this.type = "none";
        }
        else {
            this.type = "no-line";
        }
        this.redraw();
    }
    redraw() {
        this.line.classList.remove("none");
        this.line.classList.remove("line");
        this.line.classList.remove("no-line");
        this.line.classList.add(this.type);
    }
    getLineType() {
        return this.type;
    }
    setLineType(type) {
        this.type = type;
        this.redraw();
    }
}
exports.LineItem = LineItem;


/***/ }),

/***/ "../wasm/pkg/loop_puzzle_web_bg.wasm":
/*!*******************************************!*\
  !*** ../wasm/pkg/loop_puzzle_web_bg.wasm ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* harmony import */ var WEBPACK_IMPORTED_MODULE_0 = __webpack_require__(/*! ./loop_puzzle_web_bg.js */ "../wasm/pkg/loop_puzzle_web_bg.js");
module.exports = __webpack_require__.v(exports, module.id, "bd207f80483677d97668", {
	"./loop_puzzle_web_bg.js": {
		"__wbg_crypto_70a96de3b6b73dac": WEBPACK_IMPORTED_MODULE_0.__wbg_crypto_70a96de3b6b73dac,
		"__wbindgen_is_object": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_object,
		"__wbg_process_dd1577445152112e": WEBPACK_IMPORTED_MODULE_0.__wbg_process_dd1577445152112e,
		"__wbg_versions_58036bec3add9e6f": WEBPACK_IMPORTED_MODULE_0.__wbg_versions_58036bec3add9e6f,
		"__wbg_node_6a9d28205ed5b0d8": WEBPACK_IMPORTED_MODULE_0.__wbg_node_6a9d28205ed5b0d8,
		"__wbindgen_is_string": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_string,
		"__wbindgen_object_drop_ref": WEBPACK_IMPORTED_MODULE_0.__wbindgen_object_drop_ref,
		"__wbg_msCrypto_adbc770ec9eca9c7": WEBPACK_IMPORTED_MODULE_0.__wbg_msCrypto_adbc770ec9eca9c7,
		"__wbg_require_f05d779769764e82": WEBPACK_IMPORTED_MODULE_0.__wbg_require_f05d779769764e82,
		"__wbindgen_is_function": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_function,
		"__wbindgen_string_new": WEBPACK_IMPORTED_MODULE_0.__wbindgen_string_new,
		"__wbg_getRandomValues_3774744e221a22ad": WEBPACK_IMPORTED_MODULE_0.__wbg_getRandomValues_3774744e221a22ad,
		"__wbg_randomFillSync_e950366c42764a07": WEBPACK_IMPORTED_MODULE_0.__wbg_randomFillSync_e950366c42764a07,
		"__wbg_newnoargs_c9e6043b8ad84109": WEBPACK_IMPORTED_MODULE_0.__wbg_newnoargs_c9e6043b8ad84109,
		"__wbg_call_557a2f2deacc4912": WEBPACK_IMPORTED_MODULE_0.__wbg_call_557a2f2deacc4912,
		"__wbindgen_object_clone_ref": WEBPACK_IMPORTED_MODULE_0.__wbindgen_object_clone_ref,
		"__wbg_self_742dd6eab3e9211e": WEBPACK_IMPORTED_MODULE_0.__wbg_self_742dd6eab3e9211e,
		"__wbg_window_c409e731db53a0e2": WEBPACK_IMPORTED_MODULE_0.__wbg_window_c409e731db53a0e2,
		"__wbg_globalThis_b70c095388441f2d": WEBPACK_IMPORTED_MODULE_0.__wbg_globalThis_b70c095388441f2d,
		"__wbg_global_1c72617491ed7194": WEBPACK_IMPORTED_MODULE_0.__wbg_global_1c72617491ed7194,
		"__wbindgen_is_undefined": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_undefined,
		"__wbg_call_587b30eea3e09332": WEBPACK_IMPORTED_MODULE_0.__wbg_call_587b30eea3e09332,
		"__wbg_buffer_55ba7a6b1b92e2ac": WEBPACK_IMPORTED_MODULE_0.__wbg_buffer_55ba7a6b1b92e2ac,
		"__wbg_newwithbyteoffsetandlength_88d1d8be5df94b9b": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithbyteoffsetandlength_88d1d8be5df94b9b,
		"__wbg_new_09938a7d020f049b": WEBPACK_IMPORTED_MODULE_0.__wbg_new_09938a7d020f049b,
		"__wbg_set_3698e3ca519b3c3c": WEBPACK_IMPORTED_MODULE_0.__wbg_set_3698e3ca519b3c3c,
		"__wbg_newwithlength_89eeca401d8918c2": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithlength_89eeca401d8918c2,
		"__wbg_subarray_d82be056deb4ad27": WEBPACK_IMPORTED_MODULE_0.__wbg_subarray_d82be056deb4ad27,
		"__wbindgen_throw": WEBPACK_IMPORTED_MODULE_0.__wbindgen_throw,
		"__wbindgen_memory": WEBPACK_IMPORTED_MODULE_0.__wbindgen_memory
	}
});

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && !queue.d) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = 1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/wasm loading */
/******/ 	(() => {
/******/ 		__webpack_require__.v = (exports, wasmModuleId, wasmModuleHash, importsObj) => {
/******/ 			var req = fetch(__webpack_require__.p + "" + wasmModuleHash + ".module.wasm");
/******/ 			if (typeof WebAssembly.instantiateStreaming === 'function') {
/******/ 				return WebAssembly.instantiateStreaming(req, importsObj)
/******/ 					.then((res) => (Object.assign(exports, res.instance.exports)));
/******/ 			}
/******/ 			return req
/******/ 				.then((x) => (x.arrayBuffer()))
/******/ 				.then((bytes) => (WebAssembly.instantiate(bytes, importsObj)))
/******/ 				.then((res) => (Object.assign(exports, res.instance.exports)));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./ts/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=index.js.map